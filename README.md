
# OpenCV
## 图片读写
### imread（）图像载入  P65
BGR
### imshow（）图像显示 P66
InputArray
### imwrite（）输出图像到文件 P68
### 随机数产生器RNG
http://blog.csdn.net/yang_xian521/article/details/6931385
### setMouseCallback（） 鼠标操作 P93
### createTrackbar（） 滑条 P73

## Core组件
### Mat P87
由两个数据组成：矩阵头和指向存储所有像素值的矩阵     
赋值运算符和拷贝构造函数只复制信息头     
调用copyTo和clone才是真正的拷贝     
像素值存储：编码（RGB、HSV、HLS、YUV【在jpeg图片格式广泛使用】、CIE）     
显示创建Mat：1、CV_8UC3表示使用8位的unsigned char，每个元素组成三通道     
调用create函数，旧内容将会被释放     
使用cvtColor进行颜色空间转换 Opencv默认图片通道存储顺序是BGR     
### 访问像素的三个方法
### ROI
### 分离颜色通道、合并颜色通道
### 图像对比度、亮度
g(x) = a * f (x) + b，a是对比度、b是亮度，f(x)是源图像像素
### 离散傅里叶变换
一张图片使用傅里叶变换是将它分解成为正弦和余弦两部分，也就将图像从空间域转换到频域，转换后的图像为幅度图像加相位图像，幅度图像包含了原图像几乎所有的几何信息，在频域里面，一张图里高频的部分代表图像的细节和纹理信息，低频部分代表图像的轮廓信息。     
共轭复数，两个实部相等，虚部互为相反数的复数互为共轭复数(conjugate complex number)。当虚部不为零时，共轭复数就是实部相等，虚部相反,如果虚部为零，其共轭复数就是自身。（当虚部不等于0时也叫共轭虚数）复数z的共轭复数记作zˊ。同时, 复数zˊ称为复数z的复共轭
y = a * sin (bx + d) a是幅度、d是相位、f频率 = b / 2 π     
从纯粹的数学意义上看，傅立叶变换是将一个函数转换为一系列周期函数来处理的。从物理效果看，傅立叶变换是将图像从空间域转换到频率域，其逆变换是将图像从频率域转换到空间域。换句话说，傅立叶变换的物理意义是将图像的灰度分布函数变换为图像的频率分布函数     
dft（）函数     
返回dft最优尺寸大小getOptimalDFTSzie（）     
扩充图像边界 copyMakeBorder（）     
### YAML、XML读写

## 图像处理
### 滤波消除图像中的噪声成分
线性滤波算法：方框滤波、均值滤波、高斯滤波（用于剔除输入信号中不想要的频率）     
非线性滤波算法：中值滤波、双边滤波     
滤波与模糊：低通滤波是模糊，高通滤波是锐化     
图像深度是指存储每个像素所用的位数     
### 线性滤波
方框滤波：当归一化处理的时候就是均值滤波，归一化是为了统一处理和直观量化，非归一化用于计算每个像素领域内的积分特性。    
均值滤波：归一化的方框滤波，主要方法是邻域平均法，像素周围8个像素的平均值代表当前像素的值，缺点就是去噪同时也破坏了图片的细节。     
高斯滤波：每个像素的值由其自身和邻域的其他像素加权平均后得到，一般用于计算机视觉的预处理阶段，可以增强图像在不同比例大小下的图像效果。      
函数底层都是FilterEngine     
### 非线性滤波
为什么需要非线性：当噪声数据是散粒噪声而不是高斯噪声（正态分布），线性滤波过滤效果就不好     
中值滤波：克服常见线性滤波带来的图片细节模糊问题，去除脉冲噪声、椒盐噪声，又能保留图片边缘细节     
双边滤波：结合图像的空间邻进度和像素值相似度的一种折中处理，好处就是可以做边缘保存，离得较远的像素不会对边缘像素影响太多，对于高频噪声不能干净地滤掉，只能对低频信息进行较好的滤波     
### 形态学滤波
膨胀与腐蚀，它们都是对图像的高亮部分进行处理，膨胀就是对高亮部分进行膨胀，使效果图拥有比原图更大的高亮区域，腐蚀反之。     
膨胀就是求局部最大值的操作，图像与核卷积，计算核覆盖区域的像素点的最大值，并把这个最大值赋值给参考点指定的像素     
腐蚀就是求局部最小值的操作，图像与核卷积，计算核覆盖区域的像素点的最小值，并把这个最小值赋值给参考点指定的像素     
开运算就是先腐蚀后膨胀，他可以用来消除小物体，在纤细点处分离物体，并且在平滑较大的物体的边界的同时不明显改变其面积      
闭运算就是先膨胀后腐蚀，能够排除小型黑洞     
形态学梯度是膨胀图与腐蚀图之差，我们可以用它来保存物体的边缘轮廓      
顶帽运算是原图与开运算结果的差，用来分离比邻近点亮一点的斑块，当一幅图片里面的细小物品比较有规律的情况下，可以用它来进行背景提取     
黑帽运算是闭运算与原图结果的差，用来分离比邻近点暗一点的斑块。效果图有非常完美的轮廓      
浸水填充用一种特定的颜色填充与种子点相连的像素相近的连通区域，一般用来标记或者分离图像的一部分，也可以用来从图片获取掩码区域，掩码会加速处理过程或者只处理掩码指定的像素点（参考ps的魔棒）   
图像金字塔用于机器视觉和图像压缩，金字塔底部是待处理图片的高分辨率表示，而顶部是图片的低分辨率表示，有两种常用的图像金字塔：高斯金字塔和拉普拉斯金字塔，另外一个重要的应用就是图像分割。 P223    
高斯金字塔用来向下采样；拉普拉斯金字塔用来从金字塔低层图像重建上层图像，也就是预测残差，可以对图像进行最大程度的还原。
这里的向上向下与金字塔方向相反，向上是图片尺寸加倍，向下是图片尺寸减半，拉普拉斯金字塔是通过源图像减去先缩小后放大的图像的一系列图像构成。
尺寸调整resize() P227     
阈值化，对图像中像素做出取舍与决策，直接剔除一些低于或者高于阈值的像素，这样的图像分割基于图像中物体与背景之间的灰度差异 P237
## 图像变换
### 边缘检测
边缘检测的步骤：         
1、滤波，因为边缘检测算法是基于图像强度的一阶和二阶导数，而导数对噪声很敏感，一般的滤波方法是高斯滤波；       
2、增强，增强算法可以将图像的灰度点领域强度值有显著变化的点凸显出来，一般通过计算梯度幅值来确定；       
3、检测，经过增强的图像往往领域中有很多点的梯度值比较大，一般用阈值化来对这些点进行取舍；           
Canny算子：          
边缘检测算法的评价标准：低错误率、高定位率、最小响应（边缘只能标识一次，噪声不应标为边缘）
步骤：消除噪声、计算梯度的幅值和方向、非极大值抑制（排除非边缘像素）、滞后阈值（需要两个阈值，幅值超过高阈值则像素保留为边缘像素，幅值小于低阈值则像素直接被排除，幅值位于两者之间的像素仅仅在连接到一个幅值高于高阈值的像素时被保留）
sobel算子：        
Sobel算子依然是一种过滤器，只是其是带有方向的,也用于边缘检测，Sobel算子结合了高斯平滑和微分求导,更多的抗噪性       
Sobel函数求完导数后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以Sobel建立的图像位数不够，会有截断。因此要使用16位有符号的数据类型       
